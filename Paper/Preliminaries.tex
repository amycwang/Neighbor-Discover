%\section{System Model and Problem Formulation}
\section{Preliminaries}
\label{sectionmodel}

In this section, we first describe the network and node model.
Then we formulate the Neighbor Discovery problem formally.  

\subsection{Network and Node Model}

%distribution and networks
In a network, the location of the nodes are likely to obey uniform distribution[][],
Gaussian distribution[][] or other combinatorial distributions.

In reality, since the network is deployed in a vast area, each node 
has a capacity to sense a fraction of nodes within its sensing range.
These networks are defined as \emph{Partially-Connected Networks}.

Among the partially-connected networks, there is a particular type called \emph{Energy-Efficient Networks}.
A typical one of energy-efficient networks is the wireless sensor network.
The wireless sensor network consists of a number of sensors distributed separately in a target area.
The deployed sensor nodes keep their most time in sleep pattern to avoid quick energy consumption 
and wake up timely to work on duty.


When a node wake up on a time slot, it can turn to either the transmitting state or listening state. 
\begin{itemize}
\item \textbf{Transmitting state}. A node turn to transmitting state will broadcast a package containing its own identify 
information to all neighbors.
\item  \textbf{Listening state}. A node turn to listening state will monitor the frequency channel to collect its neighbors' packages.
However collision will occur when two or more neighbor nodes transmit concurrently and thus no valid information will be gathered
\end{itemize}
Transiting between the states only costs little time, compared to one complete time slot.

In our model, we denote the node set in the network as $U = \{u_1,u_2,...,u_N\}$.
Time is divided into slots of equal length $t_0$, 
which is sufficient to finish  one communication process
(transmit or receive a piece of package). In each time slot, 
a node transform its pattern according to a pre-defined duty schedule.


\begin{definition}
\textbf{Duty Schedule} is a pre-defined sequence $S=\{s^t\}_{0\leq t<T}$ of period $T$ and
$$ s^t=\left\{
\begin{aligned}
S  & & & {Sleep}\\
T  & & & {Transmit}\\
L  & & & {Listen}\\
\end{aligned}
\right.
$$
\end{definition}

 Each node construct its own duty schedule according to a specific strategy and repeats it
 until finding all the neighbors. Since the waking-up duration has a significant affect on the battery's lifetime, 
 duty cycle is utilized to restrict the energy consumption.

\begin{definition}
\textbf{Duty Cycle} represents the fraction of one period T where a node turns its radio on. It can be formulated as:

$$\theta=\frac{|\{t: 0\leq t<T, s^t \in \{T,L\}\}|}{T}.
$$
  
\end{definition}

A homogeneous energy-arrangement case is that all the nodes
in the network share a common global duty cycle $\theta$,
while each nodes holding a local duty cycle $\theta_i$ is 
a heterogeneous


\subsection{Problem Definition}

We consider a partially-connected network, 
where two nodes are neighbors if they locate within the radio range of each other. 
A  symmetric matrix $M_{N\times N}$ is used to record the neighboring relations as:

$$ M_{i,j}=\left\{
\begin{aligned}
1  & & & & & & {connected}\\
0  & & & & & & {disconnected}\\
\end{aligned}
\right.
$$

Each node follows its duty schedule to achieve neighbor discovery. In a synchronous scenario,
nodes start their neighbor discovery process at the same time, while in a asynchronous  scenario
all nodes start at different time slots. We focus on the asynchronous case while still applicable for the
synchronous situation.

 
Notice that the neighbor discovery process is not bidirectional, which means any pair of neighbors 
need to find each other separately. The time slots within which a node $u_i$ find one of its neighbors $u_j$ can be formulated 
as $L(i,j)$. Then we define the discovery latency that node $u_i$ discovers all neighbors as:
\begin{definition}
\textbf{Discovery Latency} of node $u_i$ is the time to discover all neighbors:
$$L(i) = \max_{j:M_{i,j}=1} L(i,j).
$$
\end{definition}

Thus the neighbor discovery problem can be formulated as:
%@@@to be modified
\begin{problem}
For a node $u_i$ with its neighbor set $S = \{u_{i1},u_{i2},...u_{ij},...\}$, 
design a strategy to construct a duty schedule, which satisfies
$\forall$ neighbor nodes $u_{ij}$ :
$$
\exists t \ s.t. :  \quad
S_i(t) = L ,
S_{ij}(t) = T,
\forall k \neq j : S_{ik}(t) \in \{L, S\}.
$$

\end{problem}
%@@@

\begin{figure}[!h]
\centering
\subfigure[The topology of a wireless networks ]{\includegraphics[width=1.65in]{./Figure/topology.eps}}
\vspace{0.03in}
\subfigure[Neighbor discovery process]{\includegraphics[width=2.8in]{./Figure/NBexample.eps}}
\caption{An example of neighbor discovering process. S, T and L represents Sleep pattern, 
Transmitting state and Listening state in wake-up pattern respectively.}
\label{NDexample}
%\vspace{-0.2in}
\end{figure}

An example of neighbor discovery process is given in Fig.\ref{NDexample}. 
Fig.\ref{NDexample}(a) shows the topology of a partially-connected 
wireless sensor network, which consists of $5$ sensor nodes. 
Fig.\ref{NDexample}(b) describes the neighbor discovery process 
in the asynchronous scenario, as we can see the nodes 
start their process at different time slot. The duty schedule of 
node $1$, for example, is $S_1 = \{ 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, ... \}$.  
At time slot $12$, node 5 find its neighbor node $2$ while node $1$ 
could not find node $2$ due to a collision from its another neighbor node $3$. 



